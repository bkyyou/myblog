# 1.正则表达式介绍和定义

## 写法介绍

1. 字面量写法
  /pattern/flags   // flags 有 g i m  m表示多行？？？
2. 构造函数写法
```js
var reg = new RegExp('str', 'g');
```


## 元字符

### . 匹配任何字符

### ^ $ 位置字符

### 匹配数字和字母（\w , \W）

\w 匹配数字和字母

\W 匹配非数字和字母

### 匹配数字和非数字 

\d  \D

### 匹配空白字符和非空白字符 

\s  \S

### [] 匹配其中的任意字符

[0-9a-zA-Z]

### 匹配中文

[\u4e00-\u9fa5]

### [^]

[^a-z] 匹配除了 a-z 之外的所有字符

### + 匹配一次或多次（至少一次）

### * 匹配0次或多次

### ？ 匹配0次或1次

```js
var reg = /(http|https):\/{2}w{3}\.(baidu|google)\.(com|cn)/;

reg.test('https:www.baidu.com');

console.log(RegExp.$2) // baidu

```

### () 分组

### ｜ 或者

### ?: 表示匹配不捕获

捕获方法 RegExp.$1

```js
var reg = /(http|https):\/{2}w{3}\.(?:baidu|google)\.(com|cn)/;

reg.test('https:www.baidu.com');

console.log(RegExp.$2) // com
```

### 正向预查

?=元 表示肯定是元，但是不匹配
?!元 表示肯定不是元，也不匹配

### ?= 正向肯定预查

```js
var str = '200元'  
/\d+(?=元)/  // 匹配元之前的数字 (只匹配 200 ， 元不匹配)
```

### ?！正向否定预查

```js
var reg = /\d+(?!元)/g; // 匹配一个或多个数字， 并且匹配的数字之后不是元
var str = '200元'; //  (只匹配 20 ， 0元不匹配)
var str = '200刀'; // (只匹配 200)

var reg = /\d+(?!元｜\d)/g; // 匹配一个或多个数字， 并且匹配的数字之后不是元也不是数字
var str = '200元';  // test false 
var str = '200刀';  // 匹配 200
```

### 反向预查

```js
var reg = /(?<=$)\d+/g
var str = '$200' // 匹配 200
```

### ?<= 反向肯定预查

### ?<! 反向否定预查

## 正则实例对象的方法

### test

返回一个布尔值，表示当前模式是否能匹配参数字符串

### exec

用来匹配返回的结果，如果匹配，就返回一个数组，数组中的成员都是字符串，否则返回null

## 字符串方法

### match

对字符串进行正则匹配，返回匹配的结果，否则返回null

### search

返回第一个满足条件的字符串结果在整个字符串中的位置。如果没有任何匹配，返回 -1

### replace

可以替换匹配的值。接受两个参数，第一个知识正则表达式，第二个是替换的内容

## 增则表达式案例

https://juejin.cn/post/6844903650389671943


## ？ 的作用

1. 匹配 0-1 个

2. 非贪婪模式

```js
// 只配置 8 个就停了
var reg = /\d{8,9}？/
```

## 非捕获分组

有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。

这个时候就可以使用非捕获组 （?:表达式）， 从而不捕获数据，还能使用分组的功能

例如想要匹配两个字母组成的单词或者四个字母组成的单词就可以使用非捕获分组

```js
/\b(?:\w{2}|\w{4})\b/g
```

## 分组的回溯引用

```js
/<(\w+)()<\/1>/g

'123<font>提示</bar>abcd' // 不匹配
'123<font>提示</font>abcd' // 匹配
```

## 正向先行断言

很多人也称先行断言和后行断言为环视，也有人叫预搜索，其实叫什么无所谓，重要的是知道如何使用他们

先行断言和后行断言总共有四种

1. 正向先行断言
2. 反向先行断言
3. 正向后行断言
4. 反向后行断言

* 正向先行断言： (?=表达式)， 指在某个位置向右看，表示所在位置右侧必须能匹配 表达式

例如： 我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你

如果要取出 喜欢 两个字， 要求这个喜欢后面有你， 这个时候就要这么写： 喜欢(?=你)， 这就是正向先行断言

## 提取包含大小写字母的字符串

先行断言可以用来判断字符串是否符合特定的规则，例如提取包含至少一个大小写的字母串

```js
// 表达式 提取包含至少一个大小写的字母串
var reg = /(?=.*?[a-z])(?=.*?)[A-Z].+/g // 这个有问题吧
var reg = /(?=.*?[a-z])(?=.*?[A-Z]).+/g // ? 是取消贪婪模式？

var reg = /(?=.*?[a-z])(?=.*?[A-Z]).*/g

// 至少匹配
var reg = /(?=.*?[a-z])(?=.*?[A-Z])(?=.*?[0-9]).{8, }/

a.replace(/(\d{1,2})(?=(\d{3})+$)/g, '$1,'))
```


## 反向先行断言

反向先行断言 ?!表达式 的作用是保证右边不能出现某字符

例如：我喜欢你 我喜欢 我喜欢我 喜欢 喜欢你

如果要取出 喜欢 两个字， 要求这个喜欢后面没有你， 这个时候就要这么写： 喜欢(?!你)， 这就是反向先行断言

```js
var reg = /喜欢(?!你)/gm

// 排除 qq 邮箱
// @(?!qq)
var reg = /[0-9a-zA-Z]+@(?!qq)\.com/

// 匹配标签
// 编写正则表达式匹配除 <p> 或 </p> 之外的所有标签
var reg = /(?!(p)).*(?!<\/1>)/
```

## 正向后行断言

本小结只需要你记住一句话： 先行断言和后行断言只有一个区别， 即先行断言从左往右看，后行断言从右往左看。

正向后行断言： (?<=表达式)， 指在某个位置向左看， 表示所在位置左侧必须能匹配表达式

例如： 如果要取出喜欢两个字，要求喜欢的前面有我， 后边有 你， 这个手就要这么写：(?<=我)喜欢(?=你)

```js
/(?<=我)喜欢(?=你)/

// 使用正则表达式，匹配王姓同学的名字
/(?<=王)\S+/
```

## 反向后行断言

反向后行断言： (?<!表达式)， 指在某个位置向左看，表示所在位置左侧不能匹配表达式 

例如： 如果要取出喜欢两个字，要求喜欢的前面没有，后面没有你， 这个是就要写： (?<!我)喜欢(?!你)

```js
/(?<!我)喜欢(?!你)/

// 匹配一个美元符号中的字符
/(?<!\$)\$[^\$]+\$(?!\$)/
```






