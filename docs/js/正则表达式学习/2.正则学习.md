# 2.正则学习

正则表达式是匹配模式，要么匹配字符，要么匹配位置。请记住这句话。

* 正则的目的是匹配的是一串字符，每一个规则验证 字符串中的 一段 或者说是消耗了一段字符串 ， 一段一段“向后”匹配。

* **匹配位置的字符不会让字符串接着向下匹配，不会消耗字符串中的字符**

```js
var reg = /(?=.*?[a-z])(?=.*?)[A-Z].+/g
reg.test('111aA1') // false
reg.test('Aa1') // true
```

3.2 贪婪匹配和惰性匹配

其中正则/\d{2,5}/，表示数字连续出现2到5次。会匹配2位、3位、4位、5位连续数字。

但是其是贪婪的，它会尽可能多的匹配。你能给我6个，我就要5个。你能给我3个，我就3要个。反正只要在能力范围内，越多越好。

* **贪恋模式也是会让后边匹配上才会尽可能的贪婪**

```js
const reg1 = /(?=.*[0-9])/g
reg1.test('1')  // true
reg1.test('1a') // true
reg1.test('a1') // true
reg1.test('11') // true
```

2. 如何匹配位置呢？

在ES5中，共有6个锚字符：

> ^ $ \b \B (?=p) (?!p)

* **匹配的是位置， 所以可以有多个 开头符号(^)和多个结尾符号($)** 

```js
var reg = /(?!^[0-9]{6,12}$)(?!^[a-z]{6,12}$)(?!^[A-Z]{6,12}$)^[0-9A-Za-z]{6,12}$/;
```

```js
var reg = /^\s*(.*?)\s*$/g

function trim(str) {
	return str.replace(/^\s*(.*?)\s*$/g, "$1");
}
console.log( trim("  foobar   ") ); 
// => "foobar"
```

* 科学转换
```js
const reg = /(?<!^)(?<!-)(?=(\d{3})+($|\.))(?<!\.\d*)/g
console.log('11111.1111'.replace(reg, ','));
```

> 这里使用了惰性匹配*?，不然也会匹配最后一个空格之前的所有空格的。

* 正则验证尽可能会保证你给的字符串是符合规则的

```js
const reg = /^.*\d$/g
const str = '1';
reg.test(str)
```

```js
// 去掉字符串开头和结尾的空格
const reg = /^\s+|\s+$/g

// 驼峰化
const reg = /-[a-z]/

// 匹配成对标签
const reg = /<(.+)>.*<\1>/
```

其他属性：RegExp.$1 、 RegExp.$2 … RegExp.$9 ，分别用于存储第一、第二……第九个匹配的捕获组，在
调用 exec() 或 test() 方法时，这些属性会被自动填充



* 正则学习网站
https://jex.im/regulex/#!flags=&re=ab%3F(c%7Cde*)%2B%7Cfg


https://blog.csdn.net/qq_42025192/article/details/92845147

