#  React Hooks

出处: 
https://juejin.cn/post/6844904072168865800  <br>
https://zh-hans.reactjs.org/docs/hooks-effect.html

## useState

### 作用

useState 的出现是：在函数组件里面使用 class的setState

### 使用useState

使用

```js
const [name, setName] = useState('rose')
```

### useState踩坑知识点

1. 重点： useState的初始值，只在第一次有效

举个例子：

当我点击按钮修改name的值的时候，我发现在Child组件， 是收到了，但是并没有通过useState赋值给name！

```js
const Child = memo(({data}) =>{
    console.log('child render...', data)
    const [name, setName] = useState(data)
    return (
        <div>
            <div>child</div>
            <div>{name} --- {data}</div>
        </div>
    );
})

const Hook =()=>{
    console.log('Hook render...')
    const [count, setCount] = useState(0)
    const [name, setName] = useState('rose')

    return(
        <div>
            <div>
                {count}
            </div>
            <button onClick={()=>setCount(count+1)}>update count </button>
            <button onClick={()=>setName('jack')}>update name </button>
            <Child data={name}/>
        </div>
    )
}
```

## useEffect

useEffect 的出现是 ： 在函数组件里面使用 class的生命周期函数，还是所有函数的合体！


### 使用useEffect

```js
useEffect(()=>{
    ...
})
```

### useEffect知识点合集

1. 只在第一次使用的componentDidMount，可以用来请求异步数据...

> useEffect最后，加了[]就表示只第一次执行

```js
useEffect(()=>{
    const users = 获取全国人民的信息()
},[])
```

2. 用来替代willUpdate等每次渲染都会执行的生命函数

> useEffect最后，不加[]就表示每一次渲染都执行

```js
useEffect(()=>{
  const users = 每次都获取全国人民的信息()
})
```

3. 每次渲染都执行感觉有点费，所以：

> useEffect最后，加[\]，并且[\]里面加的字段就表示，这个字段更改了，我这个effect才执行 <\div><\/div>

```js
useEffect(() => {
    const users = （name改变了我才获取全国人民的信息()）
},[name])
```

4. 如果我想要分别name和age呢：

> 可以写多个useEffect

```js
useEffect(() => {
    const users = （name改变了我才获取全国人民的name信息()）
},[name])

useEffect(() => {
    const users = （name改变了我才获取全国人民的age信息()）
},[age])
```

5. 如果我们之前订阅了什么，最后在willUnMount这个生命周期里面要取消订阅，这可咋用useEffect实现啊：

> 在effect的return里面可以做取消订阅的事

```js
useEffect(() => {
    const subscription = 订阅全国人民吃饭的情报！
    return () => {
        取消订阅全国人民吃饭的情报！
    }
},[])
```

为什么要取消订阅？

> 大家都知道，render了之后会执行重新useEffect，如果useEffect里面有一个每setInterval...那么每次render了，再次执行useEffect就会再创建一个setInterval，然后就混乱了...可以把下面案例return的内容删掉感受下

```js
useEffect(() => {
  console.log('use effect...',count)
  const timer = setInterval(() => setCount(count +1), 1000)
  return ()=> clearInterval(timer)
})
```

> 为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。

6. useEffect的一些暗戳戳的规则

> 1. state的值固定

> useEffect 里面使用到的state的值, 固定在了useEffect内部， 不会被改变，除非useEffect刷新，重新固定state的值

官网原话

> 如果你传入了一个空数组（[]），effect 内部的 props 和 state 就会一直拥有其初始值

> 2. useEffect不能被判断包裹

```js
const [count, setCount] = useState(0)
if(2 < 5){
   useEffect(() => {
      console.log('use effect...',count)
      const timer = setInterval(() => setCount(count +1), 1000)
      return ()=> clearInterval(timer)
    }) 
}
```

> 3. useEffect不能被打断

```js
const [count, setCount] = useState(0)
useEffect(...)

return // 函数提前结束了

useEffect(...)

```

7. 错误使用

```js
 const [timerNum, setTimerNum] = useState(2);
useEffect(() => {
  if (boolCountDown) {
    console.log('boolCountDown--1', boolCountDown)
    const timer = setInterval(() => {
      // refCountDown.current();
      console.log('timerNum', timerNum); // 每次打印 都是 2
      if (timerNum > 0) {
        setTimerNum(timerNum - 1);
      } else {
        setTimerNum(maxTime);
        setBoolCountDown(false);
        setCountDownText('重新获取');
      }

    }, 1000);
    return () => {
      console.log('boolCountDown--2', boolCountDown)
      console.log('maxTime--2', maxTime)
      clearInterval(timer)
    };
  }
}, [boolCountDown]);
```

警告

React Hook useEffect has a missing dependency: 'timerNum'. Either include it or remove the dependency array. You can also do a functional update 'setTimerNum(t => ...)' if you only need 'timerNum' in the 'setTimerNum' call  react-hooks/exhaustive-deps

React Hook useEffect缺少依赖项：'timerNum'。 包括它或删除依赖项数组。 如果只需要在“ setTimerNum”调用中使用“ timerNum”，则还可以执行功能更新“ setTimerNum（t => ...）”。react-hooks / exhaustive-deps

## useRef

### 作用

useEffect 里面使用到的state的值, 固定在了useEffect内部， 不会被改变，除非useEffect刷新，重新固定state的值。

useEffect里面的state的值，是固定的，这个是有办法解决的，就是用useRef，可以理解成useRef的一个作用：

> 就是相当于全局作用域，一处被修改，其他地方全更新...

### 使用

```js
const countRef = useRef(0)
```

### useRef知识点合集

1. 就是相当于全局作用域，一处被修改，其他地方全更新...

```js
 const [count, setCount] = useState(0)
 const countRef = useRef(0) // countRef 初始值为 0
useEffect(() => {
    console.log('use effect...',count)
    const timer = setInterval(() => {
      console.log('timer...count:', countRef.current)
      setCount(++countRef.current)
    }, 1000)
    return ()=> clearInterval(timer)
},[])
```

2. 普遍操作，用来操作dom

```js
const btnRef = useRef(null)

// 记得取消绑定事件哦！ 
return ()=> btnRef.current.removeEventListener('click',onClick, false)
```

```js
const Hook =()=>{
  const [count, setCount] = useState(0)
  const btnRef = useRef(null)

  // useEffect 里面使用到的state的值, 固定在了useEffect内部， 不会被改变，除非useEffect刷新，重新固定state的值。
  // 当前的 useEffect 被刷新了
  useEffect(() => {
    console.log('use effect...')
    const onClick = ()=>{
        setCount(count+1)
    }
    btnRef.current.addEventListener('click',onClick, false)
    return ()=> btnRef.current.removeEventListener('click',onClick, false)
  },[count])

  return(
    <div>
        <div>
          {count}
        </div>
        <button ref={btnRef}>click me </button>
    </div>
  )
}
```

## useMemo

### 作用

```js

const Child = memo(({data}) =>{
  console.log('child render...', data.name)
  return (
    <div>
        <div>child</div>
        <div>{data.name}</div>
    </div>
  );
})

const Hook =()=>{
  console.log('Hook render...')
  const [count, setCount] = useState(0)
  const [name, setName] = useState('rose')

  const data = {
      name
  }

  return(
    <div>
        <div>
            {count}
        </div>
        <button onClick={()=>setCount(count+1)}>update count </button>
        <Child data={data}/>
    </div>
  )
}

```

当我们点击按钮更新count的时候，Effect组件会render，一旦render， 执行到这一行代码：


```js
const data = {
  name
}
```

这一行代码会生成有新的内存地址的对象，那么就算带着memo的Child组件，也会跟着重新render， 尽管最后其实Child使用到的值没有改变！

这样就多余render了，感觉性能浪费了！于是useMemo 作为一个有着暂存能力的，就来了。

## 使用

```js
const data = useMemo(()=>{
    return {
      name
    }
},[name])
```


















